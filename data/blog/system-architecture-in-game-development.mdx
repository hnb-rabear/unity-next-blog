---
title: Kiến trúc hệ thống trong phát triển Game
date: 2023-09-04
lastmod: 2023-09-04
tags: ['unity', 'game development', 'architecture']
images: ['/media/c3da94df408ea096e1f76e7096477aff.jpeg']
draft: false
layout: PostSimple
summary: Giới thiệu về tầm quan trọng của kiến trúc trong phát triển App/Game, đặc điểm của một kiến trúc tốt và lợi ích dài hạn của nó. Mục tiêu của tài liệu là giúp các lập trình viên hiểu rõ hơn về kiến trúc, khám phá các nguyên tắc và mẫu thiết kế liên quan, và áp dụng những thực tiễn kiến trúc tốt nhất vào các dự án App/Game.
language: vn
---

<TOCInline toc={props.toc} />

# 1. Giới thiệu về thiết kế kiến trúc hệ thống

![](/media/c3da94df408ea096e1f76e7096477aff.jpeg)

## 1.1. Hiểu về tầm quan trọng của kiến trúc trong phát triển App/Game

Trong lĩnh vực phát triển App/Game, kiến trúc điều vô cùng quan trọng. Nó liên quan tới cấu trúc, tổ chức, và việc sắp xếp Code cũng như hệ thống. Vậy là tại sao nó quan trọng:

- Nó giống như một bản thiết kế cho lập trình viên, giúp xây dựng và sắp xếp các phần của App/Game một cách hợp lý, đảm bảo quá trình phát triển diễn ra một cách gắn kết và dễ quản lý.
- Một kiến trúc thiết kế tốt còn giúp cho việc tái sử dụng Code, mở rộng và bảo trì trở nên dễ dàng hơn, tức là bạn có thể thêm tính năng mới hay sửa đổi cái gì đó mà không phải lo sợ làm hỏng toàn bộ hệ thống.
- Điểm hay nữa là nó còn giúp cải thiện sự hợp tác giữa các thành viên trong đội, vì nó tạo ra một sự hiểu biết chung về cấu trúc của App/Game và các nguyên tắc thiết kế, nên việc làm việc cùng nhau dễ dàng hơn.

## 1.2. Những yếu tố quan trọng của một kiến trúc tốt và những lợi ích dài hạn của nó

Một kiến trúc tốt thường có những đặc điểm sau đây:

- **Tách rời module:** nghĩa là chia thành phần thành các module độc lập có thể hoạt động mà không cần phụ thuộc lẫn nhau nhiều, giúp tăng tính linh hoạt cho Code.
- **Khả năng mở rộng:** kiến trúc phải linh hoạt, có thể đối phó với sự phát triển và chứa đựng tính năng hoặc nội dung mới mà không cần phải làm đổi sửa toàn bộ cấu trúc.
- **Dễ bảo trì:** Code phải được viết gọn gàng, được sắp xếp cẩn thận và dễ hiểu, giúp cho việc sửa lỗi và thực hiện thay đổi trở nên đơn giản hơn.
- **Tối ưu hiệu suất:** kiến trúc được thiết kế với mục tiêu nân cao hiệu suất, đảm bảo App/Game chạy mượt mà và hiệu quả.
- **Tuân thủ nguyên tắc thiết kế:** kiến trúc nên tuân theo các nguyên tắc thiết kế như SOLID, KISS, và DRY để đảm bảo tính bền vững và dễ phát triển.

Một kiến trúc tốt mang lại những lợi ích sau đây:

- **Phát triển nhanh chóng hơn:** các lập trình viên có thể làm việc hiệu quả hơn, tránh xung độtvà không cần phải làm lại nhiều công việc.
- **Giảm nợ kỹ thuật:** kiến trúc gọn gàng giúp giảm thiểu nợ kỹ thuật, làm cho việc phát triển trong tương lai trở nên suôn sẻ hơn.
- **Hợp tác dễ dàng hơn:** các thành viên trong nhóm có thể hợp tác một cách hiệu quả hơn, hiểu code của nhau và viết code một cách thống nhất.
- **Tương lai ổn định:** một kiến trúc có khả năng thích nghi giúp cho việc mở rộng và cập nhật trong tương lai trở nên dễ dàng hơn, kéo dài vòng đời của App/Game.

## 1.3 Mục tiêu của tài liệu

- Để giúp các lập trinh viên hiểu về tầm quan trọng của kiến trúc trong phát triển App/Game và tác động của nó đến sự thành công của dự án.
- Để giới thiệu những đặc điểm của một kiến trúc tốt và những lợi ích dài hạn của nó.
- Để khám phá các nguyên tắc và mẫu thiết kế liên quan đến phát triển App/Game, đặc biệt là về vai trò của chúng trong việc tạo ra một kiến trúc tốt.
- Để cung cấp hướng dẫn thực tế về cách tạo ra và duy trì một kiến trúc được cấu trúc tốt suốt quá trình phát triển App/Game.
- Để tạo môi trường học tập tương tác, nơi các bạn có thể chia sẻ kinh nghiệm, đặt câu hỏi và tham gia vào cuộc thảo luận về những thách thức và giải pháp về kiến trúc.
- Để trang bị cho các bạn kiến thức và công cụ để áp dụng những thực tiễn kiến trúc tốt nhất vào các dự án App/Game của riêng họ, từ đó cải thiện hiệu suất phát triển và chất lượng Code.

# 2. Understanding Complexity in Game Development

![](/media/48eabe00011ba825e62ef44684731c55.jpeg)

## 2.1 Tính phức tạp trong việc phát triển Game và tại sao quản lý nó một cách hiệu quả là rất quan trọng.

Việc phát triển Game phức tạp do sự kết hợp của nhiều hệ thống tương tác cần hoạt động một cách hòa hợp để tạo ra trải nghiệm mượt mà và thú vị cho người chơi:

- **Hệ thống tương tác:** Game cần đến sự tương tác giữa các hệ thống khác nhau như vật lý, đồ họa, hoạt ảnh, trí tuệ nhân tạo, âm thanh và đầu vào của người dùng. Điều phối các hệ thống này đòi hỏi kế hoạch và triển khai cẩn thận.
- **Ràng buộc thời gian thực:** khác với các ứng dụng phần mềm truyền thống, Game đòi hỏi phản ứng ngay lập tức đối với đầu vào của người dùng. Tính thời gian thực này làm tăng thêm tính phức tạp để đảm bảo trải nghiệm Game mượt mà và điều khiển đáp ứng.
- **Sự hợp tác đa ngành:** việc phát triển Game đòi hỏi sự hợp tác giữa các lĩnh vực đa dạng, bao gồm lập trình viên, nghệ sĩ, nhà thiết kế và kỹ sư âm thanh. Kết hợp công việc của họ một cách hài hòa có thể khó khăn.
- **Quy trình thiết kế lặp:** Game thường phải trải qua nhiều phiên bản và thay đổi thường xuyên trong quá trình phát triển. Quản lý những thay đổi này mà không gây ra lỗi mới hoặc làm hỏng chức năng hiện có đòi hỏi kiểm soát phiên bản và kiểm tra cẩn thận.
- **Đa dạng nền tảng:** Game được phát triển cho nhiều nền tảng khác nhau, mỗi nền tảng có phần cứng, khả năng hiệu suất và hạn chế riêng. Đảm bảo tính tương thích trên các nền tảng này thêm phần phức tạp cho quá trình phát triển.
- **Trải nghiệm người chơi:** Game cần thu hút người chơi và tạo ra những cảm xúc hoặc trải nghiệm cụ thể. Điều này đòi hỏi những thiết kế tinh tế trong Game.

Quản lý hiệu quả là rất quan trọng đối với sự phát triển Game vì:

- **Khả năng bảo trì:** Code được quản lý tốt dễ dàng bảo trì, cho phép các nhà phát triển thêm tính năng, sửa lỗi và cải thiện mà không gây ra hậu quả không mong muốn.
- **Khả năng mở rộng:** bằng cách quản lý tính phức tạp, Game có thể được thiết kế để phục vụ các sự kiện mở rộng hoặc thay đổi trong tương lai mà không trở nên quá khó quản lý hoặc đòi hỏi viết lại đáng kể.
- **Hiệu quả:** quản lý tính phức tạp dẫn đến các phương pháp phát triển hiệu quả hơn, giảm thời gian và chi phí phát triển.
- **Trải nghiệm người dùng:** Game được cấu trúc tốt có khả năng cung cấp trải nghiệm mượt mà và thú vị, tăng cường sự hài lòng và sự vui vẻ của người chơi.

## 2.2 Những thách thức trong việc xử lý đa dạng các yếu tốc trong phát triển Game

- **Cơ chế Game:** đảm bảo cân bằng Game, đảm bảo tính công bằng, vui vẻ, và cung cấp sự lựa chọn có ý nghĩa cho người chơi đòi hỏi xem xét cẩn thận.
- **Assets**: Game thường có một lượng lớn assets bao gồm mô hình 3d, hình ảnh, hoạt ảnh và tệp âm thanh. Sắp xếp, quản lý và tối ưu hóa các tài sản này để đảm bảo hiệu suất có thể trở nên khó khăn.
- **Tương tác:** triển khai các yếu tố tương tác khác nhau như tương tác giữa người chơi và nhân vật, tương tác với các đối tượng và hành vi của nhân vật không phải người chơi đòi hỏi kịch bản và phối hợp tinh vi.
- **Giao diện người dùng (ui):** tạo ra giao diện người dùng trực quan và hấp dẫn là điều cần thiết để thu hút người chơi. Thiết kế các yếu tố giao diện người dùng mà đáp ứng, dễ truy cập và hiệu quả trên các thiết bị khác nhau có thể trở nên phức tạp.
- **Đa ngôn ngữ:** dịch Game sang nhiều ngôn ngữ và thích nghi với các văn hóa khác nhau.
- **Kiểm tra và sửa lỗi:** sự phức tạp của Game có thể dẫn đến tăng số lượng lỗi và vấn đề tiềm ẩn. Kiểm tra toàn diện và việc sửa lỗi hiệu quả trở thành điều quan trọng để tạo ra sản phẩm cuối cùng hoàn thiện.
- **Hiệu suất:** đảm bảo hiệu suất tối ưu, đặc biệt là trong các Game có đồ họa phức tạp, là một thách thức không ngừng.

# 3. Scalability in Game Development

![](/media/1740b516d68827fad4a4a8c872151aa1.jpeg)

## 3.1 Định nghĩa khả năng mở rộng trong phát triển Game.

Khả năng mở rộng trong phát triển Game đề cập đến khả năng của một Game hoặc các hệ thống cơ bản của nó để xử lý một tải công việc, cơ sở người dùng hoặc nội dung ngày càng tăng mà không làm giảm hiệu suất hoặc trải nghiệm người dùng.

Khả năng mở rộng có thể thể hiện ở các khía cạnh khác nhau trong phát triển Game, bao gồm:

- **Khả năng mở rộng hiệu suất:** Game duy trì hiệu suất ổn định và đáng tin cậy ngay cả khi sự phức tạp và yêu cầu về tài nguyên tăng lên.
- **Khả năng mở rộng nội dung:** Game có thể xử lý thêm nội dung như các cấp độ mới, tài sản và tính năng mà không làm quá tải quy trình phát triển hoặc ảnh hưởng tiêu cực đến thời gian tải.
- **Khả năng tăng thêm users:** khi có nhiều người chơi truy cập Game cùng một lúc, hạ tầng máy chủ có khả năng mở rộng cho phép trải nghiệm đa người chơi trôi chảy mà không gặp khó khăn.

## 3.2 Tầm quan trọng của việc xây dựng hệ thống có khả năng thích ứng với thay đổi.

Xây dựng hệ thống có khả năng mở rộng trong phát triển Game rất quan trọng vì một số lý do sau:

- **Trải nghiệm người dùng:** hệ thống có khả năng thích ứng đảm bảo rằng người chơi có trải nghiệm mượt mà và thú vị, không kể họ sử dụng thiết bị nào hoặc mức phức tạp của Game.
- **Tính bền vững:** hệ thống có khả năng mở rộng kéo dài tuổi thọ của Game bằng cách thích ứng với các cập nhật, mở rộng và thêm nội dung trong tương lai.
- **Tiếp cận thị trường:** Game có thể chạy trên nhiều thiết bị khác nhau sẽ mở rộng thị trường.
- **Tối ưu hiệu suất:** hệ thống có khả năng mở rộng quản lý tài nguyên tốt hơn, dẫn đến hiệu suất tối ưu trên các nền tảng khác nhau.
- **Duy trì người chơi:** một trải nghiệm mượt mà khuyến khích sự trung thành của người chơi và tạo ra đánh giá tích cực.
- **Phát triển nhanh và hiệu quả:** hệ thống có khả năng mở rộng đơn giản hóa phát triển trong tương lai, giảm sự cần thiết cho các thay đổi lớn và giảm thiểu nợ kỹ thuật.

## 3.3 Hậu quả của một kiến trúc không có khả năng mở rộng tốt.

Một kiến trúc không có khả năng mở rộng tốt có thể dẫn đến nhiều hậu quả tiêu cực:

- **Vấn đề hiệu suất:** Hệ thống không có khả năng mở rộng tốt có thể gặp vấn đề về fps thấp, tải lâu, lag, ảnh hưởng tiêu cực đến trải nghiệm của người chơi.
- **Giới Hạn Phần Cứng:** Kiến trúc không linh hoạt có thể giới hạn khả năng chạy trên các thiết bị cấu hình thấp, lầm mất một phần users.
- **Thách thức trong Bảo Trì:** Thiếu khả năng mở rộng khiến việc thêm tính năng hoặc nội dung mới trở nên khó khăn, thường đòi hỏi viết lại hoặc phải tìm giải pháp tạm thời.
- **Nợ Kỹ Thuật:** Kiến trúc không có khả năng mở rộng tích luỹ nợ kỹ thuật, làm cho việc cập nhật và sửa lỗi trong tương lai trở nên khó khăn và tốn thời gian.
- **Tăng Chi Phí Phát Triển:** Sửa các vấn đề về khả năng mở rộng sau khi hoàn thành dự án có thể dẫn đến tăng chi phí phát triển và kéo dài thời gian dự án.
- **Mất Người Chơi:** Người chơi bị thất vọng có thể bỏ Game, dẫn đến mất doanh thu và đánh giá tiêu cực.

Để tránh những hậu quả này, các nhà phát triển nên đặt ưu tiên cho khả năng mở rộng trong suốt quá trình phát triển và đưa ra các quyết định thiết kế cho phép Game thích ứng linh hoạt.

# 4. Principles of Architecture Design

## 4.1. Nguyên tắc SOLID

![](/media/3f7e189f204903fca49bf89806ce7b85.png)

SOLID là một tập hợp năm nguyên tắc thiết kế hướng đối tượng nhằm tạo ra hệ thống có cấu trúc tốt, dễ bảo trì và mở rộng. Các nguyên tắc này được sử dụng rộng rãi trong phát triển phần mềm hay Game, để đảm bảo rằng Code vẫn linh hoạt và có khả năng mở rộng khi dự án phát triển.

- **Single Responsibility Principle (SRP):** một lớp hoặc module chỉ nên có một trách nhiệm duy nhất. Nghĩa là, nó nên chịu trách nhiệm cho một công việc cụ thể hoặc một khía cạnh cụ thể của ứng dụng, và không nên kết hợp nhiều trách nhiệm không liên quan vào cùng một lớp hoặc module. Điều này giúp dễ dàng bảo trì, mở rộng và tái sử dụng mã, cũng như làm cho mã trở nên rõ ràng và dễ đọc hơn.
- **Open-Closed Principle (OCP):** một module phải được thiết kế để mở rộng (open) để có thể thêm chức năng mới mà không cần sửa đổi Code đã tồn tại (closed). Điều này có nghĩa là bạn có thể mở rộng tính năng của một lớp hoặc module bằng cách viết lớp mới hoặc module mới thay vì sửa đổi Code của lớp hoặc module đã có. OCP giúp giảm nguy cơ gây ra lỗi và tăng khả năng tái sử dụng mã, vì bạn có thể thêm tính năng mới mà không ảnh hưởng đến các phần khác của ứng dụng đã hoạt động
- **Liskov Substitution Principle (LSP):** các đối tượng con của một lớp cơ sở (base class) nên có thể thay thế hoàn toàn cho đối tượng của lớp cơ sở mà không làm thay đổi tính đúng đắn của chương trình. Nghĩa là, nếu một lớp con được sử dụng thay thế cho lớp cơ sở, thì phải đảm bảo rằng lớp con hoạt động theo cùng những quy tắc và hành vi của lớp cơ sở mà không gây ra lỗi hoặc thay đổi không mong muốn trong ứng dụng. Điều này giúp đạt được tính đúng đắn và dễ bảo trì.
- **Interface Segregation Principle (ISP):** một lớp không nên phải triển khai các phương thức mà nó không sử dụng. Nghĩa là khi bạn định nghĩa một giao diện (interface), hãy đảm bảo rằng các lớp sử dụng giao diện đó chỉ cần triển khai những phương thức cần thiết cho mình, và không bị ép buộc triển khai các phương thức không liên quan. ISP giúp tránh tạo ra các giao diện quá lớn và phức tạp, đồng thời tạo ra các giao diện nhỏ gọn, dễ quản lý và dễ sử dụng.
- **Dependency Inversion Principle (DIP):** Các module cấp cao không nên phụ thuộc vào các module cấp thấp. Cả hai nên phụ thuộc vào một giao diện trừu tượng. Các module cấp thấp nên triển khai giao diện trừu tượng mà không làm thay đổi giao diện đó. DIP thúc đẩy việc sử dụng giao diện trừu tượng để giảm sự phụ thuộc giữa các thành phần trong hệ thống. Điều này giúp tạo ra các module độc lập, dễ kiểm thử và tái sử dụng, và giúp tăng tính linh hoạt của hệ thống.

Bằng việc tuân thủ các nguyên tắc SOLID này, các nhà phát triển có thể tạo ra kiến trúc dễ bảo trì và linh hoạt hơn, dẫn đến Code không kết nối chặt chẽ, cơ cấu tốt hơn và dễ dàng thích ứng với các thay đổi hoặc tính năng mới.

## 4.2. KISS (Keep It Simple, Stupid)

![](/media/b164ce4d76d34ede1fcbad103d4d0379.png)

Nguyên tắc này khuyến nghị rằng khi thiết kế và triển khai hoặc giải quyết các vấn đề trong dự án, bạn nên giữ cho giải pháp của mình đơn giản và không cần thiết phức tạp hóa nó.

- Giảm sự phức tạp: Tránh sử dụng cách làm phức tạp khi có thể sử dụng cách đơn giản hơn để đạt được mục tiêu. Sự phức tạp có thể làm tăng nguy cơ lỗi và khó bảo trì.
- Dễ hiểu: Code và giải pháp đơn giản dễ đọc, dễ hiểu, và dễ bảo trì. Điều này hỗ trợ cả cá nhân lập trình viên và đội ngũ làm việc cùng nhau trên dự án.
- Tối ưu hóa: Tích hợp KISS có thể giúp tối ưu hóa hiệu suất và tài nguyên, vì các giải pháp đơn giản thường có hiệu quả cao hơn và ít tốn tài nguyên.

## 4.3. DRY (Don't Repeat Yourself)

![](/media/43f3054313e3a6da0372b091561d1d76.png)

Nguyên tắc này khuyến nghị rằng bạn không nên lặp lại thông tin hoặc logic trong Code của mình, mà nên sử dụng một phần mã chung hoặc một khái niệm trừu tượng để tái sử dụng và duy trì.

- Giảm sự phức tạp: Bằng cách tránh lặp lại mã, bạn giảm sự phức tạp của Code và giúp nó trở nên dễ đọc và dễ hiểu hơn.
- Dễ bảo trì: Khi bạn cần thay đổi một phần của mã, bạn chỉ cần thay đổi ở một nơi duy nhất, giúp giảm nguy cơ gây ra lỗi và tiết kiệm thời gian trong việc bảo trì mã.
- Tính nhất quán: DRY giúp đảm bảo rằng thông tin và logic không mâu thuẫn trong mã, đảm bảo tính nhất quán của hệ thống.
- Tái sử dụng: Mã không lặp lại thường dễ dàng tái sử dụng trong các phần khác của dự án hoặc trong các dự án khác.

## 4.4. Composition over inheritance (Sử dụng sáng tạo hơn là kế thừa)

![](/media/8546919232a067202a72fcdbe5bfb3e5.png)

Nguyên tắc này khuyến nghị sử dụng việc sáng tạo các lớp mới bằng cách sử dụng tính chất hợp thành (composition) thay vì kế thừa từ các lớp đã tồn tại (inheritance).

Thay vì sử dụng kế thừa, bạn nên tạo ra các đối tượng mới bằng cách kết hợp nhiều thành phần (objects) khác nhau để đạt được tính năng và hành vi mong muốn. Bằng cách này, bạn có thể tạo ra các cấu trúc phức tạp hơn bằng cách sắp xếp và kết hợp các thành phần có sẵn một cách linh hoạt, thay vì bị giới hạn bởi cấu trúc kế thừa.

Lý do chính để ưu tiên Composition over inheritance bao gồm:

- **Tính linh hoạt:** Composition cho phép bạn thay đổi và mở rộng chức năng của đối tượng một cách dễ dàng hơn, bằng cách thêm hoặc thay đổi các thành phần một cách độc lập.
- **Tránh vấn đề kế thừa:** Kế thừa có thể dẫn đến các vấn đề phức tạp như hiện tượng "diamond problem" và tạo ra sự phụ thuộc chặt chẽ giữa các lớp, trong khi Composition giảm điều này.
- **Tái sử dụng code:** Composition thúc đẩy tái sử dụng Code, vì bạn có thể sử dụng các thành phần đã được xây dựng và kiểm thử trong nhiều ngữ cảnh khác nhau.

# 5. Design Patterns in Unity

## 5.1. Design patterns cho các vấn đề phổ biến trong phát triển phần mềm hay Game.

Design Patterns là những giải pháp đã được thiết lập để giải quyết các vấn đề lặp đi lặp lại trong thiết kế. Chúng cung cấp cho các nhà phát triển các phương pháp đã được kiểm chứng và có thể tái sử dụng để giải quyết các thách thức phổ biến.

Design Patterns có thể được phân loại thành ba loại:

- **Creational Patterns**: Các mẫu này tập trung vào việc tạo ra và khởi tạo đối tượng, cung cấp các cách linh hoạt để tạo đối tượng mà không làm cho Code kết nối chặt chẽ với các lớp của chúng.
- **Structural Patterns**: Các mẫu này đối phó với việc tổ chức các lớp và đối tượng, đơn giản hóa mối quan hệ và tương tác giữa chúng.
- **Behavioral Patterns**: Các mẫu này quản lý việc giao tiếp và hợp tác giữa các lớp, xác định cách các đối tượng tương tác và phân phối trách nhiệm.

## 5.2. Design patterns thông dụng trong phát triển Game:

### 5.2.1. Singleton Pattern để quản lý tài nguyên và hệ thống toàn cục:

Singleton Pattern đảm bảo rằng một lớp chỉ có một instance duy nhất và cung cấp một điểm truy cập toàn cục đến instance đó. Thường được sử dụng để quản lý tài nguyên và hệ thống nên có một instance duy nhất và tập trung trong suốt thời gian hoạt động của ứng dụng.

Trong phát triển game Unity, Singleton Pattern thường được sử dụng để quản lý các hệ thống toàn cục như quản lý Game, quản lý âm thanh hoặc quản lý đầu vào. Nó giúp ngăn ngừa việc có nhiều instance của các hệ thống này, đảm bảo rằng chúng duy trì tính nhất quán và chia sẻ dữ liệu giữa các phần khác nhau của Game.

### 5.2.2. Observer Pattern để xử lý tương tác dựa trên sự kiện giữa các yếu tố trong Game:

Observer Pattern giúp cho việc giao tiếp giữa các đối tượng diễn ra theo sự kiện. Trong pattern này, một đối tượng (được gọi là đối tượng quan sát - subject) duy trì một danh sách các đối tượng phụ thuộc (được gọi là người quan sát - observers) và thông báo tự động cho các người quan sát này khi trạng thái của đối tượng quan sát thay đổi.

Trong Unity, Observer pattern thường được sử dụng để triển khai hệ thống sự kiện. Ví dụ, khi một kẻ địch bị tiêu diệt, hệ thống sự kiện có thể thông báo cho các yếu tố trong Game khác nhau như quản lý điểm số của người chơi, các thành phần giao diện người dùng và quản lý âm thanh để phản ứng một cách thích hợp. Điều này tách rời subject (đối tượng quan sát) và observers (người quan sát), dẫn đến Code dễ bảo trì và linh hoạt hơn.

### 5.2.3. Factory Pattern để tạo ra các đối tượng có độ phức tạp khác nhau:

Factory pattern cung cấp một giao diện để tạo ra các đối tượng mà không cần chỉ định chính xác lớp của chúng. Nó bao gồm việc khởi tạo các đối tượng, cho phép các nhà phát triển tạo ra các đối tượng có độ phức tạp hoặc loại khác nhau thông qua một giao diện chung.

Trong phát triển game Unity, Mẫu Factory rất hữu ích cho việc tạo ra các đối tượng, đặc biệt là khi bạn cần làm việc với các loại enemy khác nhau, power-ups hoặc các thành phần của màn chơi. Factory có thể xác định lớp cụ thể nào sẽ được tạo dựa trên các tham số đầu vào hoặc điều kiện của Game, giúp thúc đẩy khả năng tái sử dụng mã và dễ bảo trì.

# 6. Quy tắc đặt tên (Naming conventions)

Một số quy tắc và hướng dẫn quan trọng về quy tắc đặt tên:

- **Rõ ràng và mang ý nghĩa:** Tên nên rõ ràng, đúng mô tả và mang ý nghĩa. Sử dụng tên thể hiện chính xác mục đích và chức năng của thành phần mà chúng đại diện. Tránh sử dụng tên viết tắt hoặc tên không rõ ràng..
- **Sử dụng CamelCase:** Trong CamelCase, các từ ghép được viết liền không cách khoảng, và mỗi từ sau từ đầu tiên bắt đầu bằng một chữ cái viết hoa. Ví dụ: playerScore, enemyHealth, moveForward*.*
- **Sử dụng PascalCase cho Lớp và Enums:** Tên lớp và tên enum nên sử dụng PascalCase, trong đó mỗi từ bắt đầu bằng một chữ cái viết hoa. Ví dụ: PlayerController, GameState, WeaponType.
- **Sử dụng ALL_CAPS cho Hằng số:** Hằng số nên viết bằng ALL*CAPS với dấu gạch chân (*) ngăn cách các từ. Ví dụ: MAX_PLAYERS, DEFAULT_SPEED, PI_VALUE*.*
- **Tránh Viết Tắt:** Tránh sử dụng viết tắt trừ khi chúng phổ biến và được chấp nhận. Sử dụng tên mô tả thay vì viết tắt để nâng cao sự đọc hiểu.
- **Sử dụng Cặp Động Từ - Danh Từ:** Đối với hàm và phương thức, sử dụng cặp động từ - danh từ để chỉ định hành động và mục đích của chúng. Ví dụ: calculateDamage(), updatePlayerPosition()
- **Tránh Ký Tự Đặc Biệt:** Tránh sử dụng ký tự đặc biệt như gạch dưới (\_) hoặc dấu đô la (\$) trong tên trừ khi cần thiết. Chúng có thể làm cho tên trở nên khó đọc và bảo trì.
- **Nhất Quán:** Đảm bảo tính nhất quán trong quy tắc đặt tên trên toàn bộ Code. Tính nhất quán giúp các nhà phát triển nhanh chóng hiểu Code và tìm các thành phần cụ thể.
- **Sử Dụng Tiền Tố hoặc Hậu Tố Có Ý Nghĩa:** Đối với biến hoặc hàm thuộc một loại hoặc nhóm cụ thể, xem xét việc sử dụng tiền tố hoặc hậu tố có ý nghĩa. Ví dụ: isDead, hasKey, enemyHealthBar*.*
- **Tên Nên Có Thể Đọc Được:** Các tên có thể đọc được dễ dàng thảo luận và ghi nhớ trong các cuộc thảo luận nhóm.
- **Tránh kiểu Hungarian Notation:** trong đó tên biến bao gồm các tiền tố chỉ định kiểu (ví dụ: strName, intHealth), thường không được khuyến nghị trong các thực hành lập trình hiện đại.
- **Tránh Magic Numbers:** Tránh sử dụng các số ngẫu nhiên trong Code mà thiếu ngữ cảnh. Thay vì vậy, định nghĩa chúng như là hằng số với tên mô tả.
- **Sử Dụng Tiếng Anh:** Nên (phải) dùng tiếng anh để đặt tên.

Bằng việc tuân theo quy tắc đặt tên này, các nhà phát triển có thể tạo ra Code dễ đọc, dễ hiểu và dễ bảo trì. Tên có tính nhất quán và ý nghĩa cải thiện sự hợp tác giữa các thành viên trong nhóm và giảm nguy cơ xảy ra lỗi hoặc hiểu nhầm trong quá trình phát triển.

# 7. Modular Architecture

Kiến trúc modular là chia nhỏ Code của thành các mô-đul hoặc thành phần tự chứa nhỏ hơn, mỗi thành phần này chịu trách nhiệm cho một chức năng hoặc hành vi cụ thể. Các ưu điểm của việc áp dụng một kiến trúc modular như sau:

- **Tái sử dụng Code:** các nhà phát triển có thể dễ dàng sử dụng các thành phần này trong các phần khác của Game, giảm Code trùng lặp và tăng tốc quá trình phát triển.
- **Dễ bảo trì:** các thay đổi và cập nhật có thể được thực hiện trên các mô-đul cụ thể mà không ảnh hưởng đến toàn bộ Code. Điều này tách rời tác động của các thay đổi, làm cho việc bảo trì và gỡ lỗi trở nên dễ dàng hơn.
- **Khả năng mở rộng:** cho phép thêm tính năng mới hoặc mở rộng các tính năng hiện có bằng cách thêm các mô-đul mới. Khả năng mở rộng này thúc đẩy sự phát triển mà không gây ra một loạt các thay đổi trong toàn bộ dự án.
- **Sự rõ ràng và dễ đọc:** các mô-đul nhỏ chỉ tập trung vào chức năng cụ thể sẽ dễ đọc dễ hiểu hơn. Sự rõ ràng này nâng cao khả năng đọc Code và làm cho quá trình hợp tác giữa các thành viên trong nhóm trở nên hiệu quả hơn.
- **Kiểm thử và sửa lỗi:** các mô-đul có thể được kiểm thử và sửa lỗi một cách riêng lẻ, đơn giản hóa quá trình xác định và sửa lỗi, cải thiện độ chính xác của kiểm thử và giảm khả năng gây ra các lỗi mới.
- **Hợp tác nhóm:** kiến trúc modular thúc đẩy một quy trình làm việc có tổ chức hơn giữa các thành viên trong nhóm. Mỗi thành viên có thể làm việc trên các mô-đul riêng biệt mà không làm xao lẫn công việc của nhau, tạo điều kiện thuận lợi cho quá trình hợp tác suôn sẻ hơn.
- **Tổ chức Code:** kiến trúc modular làm cho việc điều hướng trong dự án và tìm các thành phần liên quan trở nên dễ dàng hơn.

# 8. Data-Driven Design

Data-Driven Design (Thiết kế dựa trên dữ liệu) là một phương pháp trong phát triển phần mềm và thiết kế Game mà các quyết định thiết kế và hành vi của ứng dụng được dựa trên dữ liệu thay vì được xác định cố định trong Code. Điều này có nghĩa rằng các thay đổi trong hành vi, nội dung, hoặc các yếu tố khác của ứng dụng có thể được thực hiện mà không cần sửa đổi Code gốc, mà thay vào đó, chỉ cần thay đổi dữ liệu.

Một số điểm quan trọng liên quan đến Data-Driven Design:

- **Dữ liệu trở thành quyết định chính**: trong data-driven design, dữ liệu đóng vai trò quan trọng trong quyết định cách mà ứng dụng hoạt động. Thay vì chương trình cố định cách mọi thứ hoạt động, dữ liệu quyết định cách chúng hoạt động.
- **Phân tách dữ liệu và Code**: Code và dữ liệu được tách biệt. Dữ liệu thường được lưu trữ trong các tệp tin hoặc cơ sở dữ liệu riêng biệt và được ứng dụng đọc và xử lý khi chạy.
- **Thay đổi dễ dàng**: dựa vào data-driven design, bạn có thể thay đổi hành vi của ứng dụng một cách nhanh chóng bằng cách chỉnh sửa hoặc thay đổi dữ liệu. Điều này làm cho việc thay đổi và cập nhật ứng dụng dễ dàng hơn và không cần phải biên dịch lại Code.
- **Quản lý dữ liệu**: cần có các công cụ và quy trình quản lý dữ liệu để đảm bảo tính nhất quán và hiệu suất. Quản lý dữ liệu đòi hỏi sự chú tâm đến việc sao lưu, phiên bản hóa, và kiểm soát dữ liệu.
- **Phù hợp cho Game và ứng dụng phức tạp**: data-driven design thường được sử dụng trong Game video và ứng dụng phức tạp khác, nơi mà có nhiều nội dung và hành vi cần quản lý

Ví dụ về Data-Driven Design trong Game có thể bao gồm việc lưu trữ thông tin về các màn chơi, nhân vật, vũ khí, và nhiều yếu tố khác trong các tệp dữ liệu riêng biệt. Khi người chơi tiến vào một màn chơi cụ thể, ứng dụng sẽ tải và xử lý dữ liệu từ tệp tương ứng để cấu hình màn chơi đó, thay vì cần phải sửa đổi Code của Game cho từng màn chơi riêng biệt. Điều này giúp làm giảm sự phức tạp và tăng tính linh hoạt.

# 9. Version Control and Collaboration

## 9.1. Chiến lược quản lý phiên bản trong quá trình phát triển.

Quản lý phiên bản là một yếu tố quan trọng trong quá trình phát triển. Nó cho phép hợp tác giữa các thành viên trong nhóm trong khi theo dõi các sự thay đổi, cho phép dễ dàng quay lại trạng thái trước đây nếu xảy ra vấn đề. Dưới đây là một số chiến lược cho quản lý phiên bản trong phát triển dựa trên nhóm:

- **Sử dụng version control systems (vcs):** triển khai một hệ thống quản lý phiên bản chuyên dụng như git, svn, hoặc perforce để theo dõi các sự thay đổi.
- **Tạo các nhánh (branching):** sử dụng các nhánh để cho phép các thành viên trong đội làm việc trên các tính năng hoặc sửa lỗi riêng biệt mà không gây xung đột với nhánh chính của dự án (thường được gọi là nhánh "master" hoặc "main").
- **Nhánh tính năng (feature branches):** khuyến khích các thành viên tạo các nhánh tính năng cho mỗi thay đổi hoặc bổ sung quan trọng vào Game. Điều này cho phép phát triển độc lập và tích hợp dễ dàng khi tính năng hoàn thành.
- **Pull requests (PR):** triển khai quy trình xem xét Code bằng cách sử dụng PR. Yêu cầu các thành viên trong đội đề xuất các sự thay đổi của họ qua PR để được xem xét trước khi hợp nhất chúng vào nhánh chính. Việc xem xét Code đảm bảo chất lượng và tính nhất quán của mã.
- **Tích hợp liên tục (continuous integration - CI):** thiết lập hệ thống CI để tự động xây dựng, kiểm tra và triển khai khi có thay đổi được đẩy lên hệ thống quản lý phiên bản. CI đảm bảo rằng mỗi thay đổi được kiểm tra trong một môi trường nhất quán, giảm thiểu các vấn đề tích hợp.
- **Git flow:** cân nhắc sử dụng mô hình git flow, một mô hình nhánh được thiết kế đặc biệt cho các dự án phát triển phần mềm hay Game.
- **Commit messages:** khuyến khích viết các mô tả commit mô tả và cung cấp thông tin về các thay đổi trong từng commit để hỗ trợ việc hiểu lịch sử phát triển.
- **Đánh dấu phiên bản (version tagging):** đánh dấu các cột mốc quan trọng hoặc bản phát hành trong quá trình phát triển, giúp dễ dàng tham khảo lại các điểm cụ thể trong lịch sử dự án.

## 9.2. Duy trì một kiến trúc nhất quán

Duy trì một kiến trúc nhất quán là rất quan trọng khi dự án mở rộng và phát triển. Tất cả thành viên nhóm tuân theo kiến trúc đã thiết lập, tạo điều kiện cho tính nhất quán của Code và giảm thiểu nợ kỹ thuật.

Dưới đây là một số thực hành để khuyến khích sự phát triển cộng tác và sự nhất quán:

- **Đánh giá Code (code reviews):** như đã đề cập trước đó, thực hiện đánh giá Code thông qua các pull requests để đảm bảo rằng tất cả các thay đổi phù hợp với kiến trúc và quy chuẩn Code đã thiết lập.
- **Hướng dẫn về cách viết mã (style guides):** xây dựng và tuân thủ một bộ quy tắc về cách viết mã cách quản lý file trong dự án.
- **Tài liệu thiết kế (design document):** tạo và duy trì một tài liệu thiết kế mô tả kiến trúc tổng quan, cấu trúc dữ liệu và các thành phần chính của Game. Tài liệu này đóng vai trò là nguồn tham khảo cho tất cả thành viên nhóm hiểu cấu trúc dự án và các quyết định thiết kế.
- **Họp nhóm (team meetings):** tổ chức các cuộc họp nhóm định kỳ để thảo luận về các quyết định kiến trúc, xem xét tiến trình và giải quyết mọi xung đột hoặc khó khăn trong việc triển khai.
- **Lập trình cặp (pair programming):** xem xét lập trình cặp, trong đó hai nhà phát triển làm việc cùng nhau trên cùng một nhiệm vụ. Thực hành này thúc đẩy chia sẻ kiến thức và khuyến khích thảo luận về các lựa chọn kiến trúc và thiết kế.
- **Tài liệu hướng dẫn (documentation):** khuyến khích việc tạo tài liệu chi tiết và cập nhật cho tất cả các thành phần và hệ thống chính. Điều này giúp các thành viên mới trong nhóm hiểu về kiến trúc hiện có và thúc đẩy tính nhất quán trong cách triển khai các hệ thống.
- **Chia sẻ kiến thức (knowledge sharing):** khuyến khích chia sẻ kiến thức giữa các thành viên nhóm, thảo luận về công nghệ hoặc tổ chức các buổi họp nội bộ về các nguyên tắc kiến trúc và các quy tắc tốt nhất.
- **Tái cấu trúc Code (codebase refactoring):** dành thời gian cho việc tái cấu trúc định kỳ của Code để cải thiện kiến trúc, giải quyết công nợ kỹ thuật và đảm bảo rằng Code vẫn có thể dễ bảo trì và mở rộng.

Bằng cách thúc đẩy các phương pháp hợp tác, các thành viên trong đội có thể làm việc cùng nhau để duy trì một kiến trúc nhất quán, dẫn đến quá trình phát triển dễ quản lý và hiệu quả hơn trong dài hạn.

# 10. Code Reviews and Refactoring:

## 10.1. Sự quan trọng của Code Review

Code reviews (đánh giá Code) là việc các thành viên trong nhóm xem xét và kiểm tra các thay đổi được thực hiện trên Code trước khi chúng được hợp nhất vào kho mã chính. Code reviews đóng một vai trò quan trọng trong việc duy trì một kiến trúc vững chắc với những lý do sau đây:

- **Chất Lượng Code (Code Quality):** Code reviews giúp đảm bảo rằng Code đáp ứng các tiêu chuẩn chất lượng. Để phát hiện ra các lỗi tiềm ẩn, vấn đề về hiệu suất và các thiết kế sai lầm, ngăn chúng khỏi việc được đưa vào Code.
- **Nhất Quán (Consistency):** Code reviews thúc đẩy sự nhất quán trong cách viết mã và các quyết định kiến trúc trên toàn dự án. Sự nhất quán này quan trọng để duy trì tính gắn kết và sự hiểu biết của Code đối với tất cả thành viên trong nhóm.
- **Chia Sẻ Kiến Thức (Knowledge Sharing):** Code reviews thúc đẩy việc chia sẻ kiến thức giữa các thành viên nhóm. Bằng cách xem xét Code của người khác, nhà phát triển có cơ hội hiểu sâu hơn về các phần khác nhau của dự án, nâng cao sự hiểu biết về hệ thống như một tổng thể.
- **Cơ Hội Học Hỏi (Learning Opportunities):** Việc xem xét Code cung cấp cơ hội cho các thành viên trong nhóm học hỏi từ phong cách viết mã, kỹ thuật và cách giải quyết vấn đề của nhau, khuyến khích một văn hóa học hỏi liên tục.
- **Phát Hiện Sớm Vấn Đề (Early Detection of Issues):** phát hiện các vấn đề sớm trong quá trình phát triển, giảm thời gian và công sức cần thiết để sửa chữa các vấn đề được phát hiện sau trong quá trình phát triển.

Để tối ưu hóa lợi ích từ code reviews, quan trọng phải thiết lập hướng dẫn đánh giá Code rõ ràng, tiến hành đánh giá thường xuyên và tạo ra một môi trường cộng tác và xây dựng nơi phản hồi được đưa ra và nhận được với sự tôn trọng và chuyên nghiệp.

## 10.2. Refactoring (Cải tạo và tối ưu Code)

Refactoring (tối ưu Code) là quá trình thực hiện các thay đổi từng bước trên Code để cải thiện thiết kế, cấu trúc và khả năng bảo trì mà không làm thay đổi hành vi bên ngoài của Code. Trong phát triển Game, refactoring là một công việc quan trọng để duy trì một kiến trúc tốt và vững chắc. Dưới đây là lý do tại sao refactoring quan trọng:

- **Loại bỏ nợ kỹ thuật (eliminating technical debt):** refactoring giúp giải quyết nợ kỹ thuật bằng cách cải thiện Code được thiết kế hoặc triển khai kém chất lượng. Nó giảm nguy cơ tích tụ nợ kỹ thuật mà trở nên ngày càng khó bảo trì theo thời gian.
- **Tăng tính đọc hiểu (enhancing readability):** refactoring làm cho Code trở nên dễ đọc và hiểu hơn. Code rõ ràng và được sắp xếp cách thức giúp dễ bảo trì và chỉnh sửa, đặc biệt khi các thành viên trong nhóm khác cần làm việc trên nó.
- **Tối ưu hóa mã (code optimization):** refactoring cho phép tối ưu hóa hiệu suất và làm Code hiệu quả và gọn gàng hơn, đồng thời cải thiện hiệu suất Game.
- **Thích ứng với yêu cầu thay đổi (adapting to changing requirements):** refactoring cho phép Code thích ứng với các yêu cầu và tính năng mới mà không tạo ra sự phức tạp không cần thiết.
- **Duy trì một kiến trúc nhất quán (maintaining a consistent architecture):** refactoring giúp đảm bảo rằng Code luôn tuân thủ kiến trúc và các mô hình thiết kế đã thiết lập.
- **Khuyến khích tái sử dụng mã (encouraging code reusability):** Code sau khi tối ưu hóa thường có tính modul và có thể tái sử dụng cao hơn, giảm sự trùng lặp mã và thúc đẩy hiệu quả trong quá trình phát triển.

Khi thực hiện refactoring, việc có bộ kiểm tra thử tốt để xác minh rằng các thay đổi không đưa ra các lỗi mới hoặc bug là rất quan trọng. Các kiểm tra tự động cung cấp một mạng an toàn trong quá trình refactoring, đảm bảo rằng Code vẫn hoạt động và ổn định sau khi thay đổi được thực hiện.
